# Check if we're on a release candidate branch (rc-*)
current_branch=$(git symbolic-ref --short HEAD)
if [[ ! "$current_branch" =~ ^rc- ]]; then
  exit 0
fi

# Skip version bump prompt for WIP commits
if grep -q "WIP" "$1"; then
  exit 0
fi

# Check if we're in a merge commit or rebase
source_type=${2:-}
if [ "$source_type" = "merge" ] || [ "$source_type" = "message" ]; then
  exit 0
fi

# Get current version
current_version=$(node -p "require('./package.json').version")

# Check if version tag already exists
tag_exists=false
if git ls-remote --tags origin "refs/tags/v$current_version" 2>/dev/null | grep -q "refs/tags/v$current_version"; then
  tag_exists=true
fi

# Propose version update if version is 0.0.0 or tag already exists
if [ "$current_version" = "0.0.0" ]; then
  echo ""
  echo "Release candidate branch detected ($current_branch) with initial version 0.0.0"
  echo "It's recommended to update the version as 0.0.0 should not be tagged."
  read -p "Do you want to update the package version? (y/n) " answer
  if [ "$answer" != "y" ]; then
    echo "Skipping version update."
    exit 0
  fi
elif [ "$tag_exists" = true ]; then
  echo ""
  echo "Release candidate branch detected ($current_branch)"
  echo "WARNING: Tag v$current_version already exists in the repository."
  read -p "Do you want to update the package version? (y/n) " answer
  if [ "$answer" != "y" ]; then
    echo "Skipping version update. Note that you will be overwriting the existing tag v$current_version."
    exit 0
  fi
else
  # Standard prompt for RC branches
  echo ""
  echo "Release candidate branch detected ($current_branch)"
  read -p "Do you want to update the package version? (y/n) " answer
  if [ "$answer" != "y" ]; then
    echo "Skipping version update."
    exit 0
  fi
fi

# Interactive version selection
echo ""
echo "Select version update type:"
echo "1) patch: Bug fixes and minor changes [e.g. 1.0.0 -> 1.0.1]"
echo "2) minor: New features backward compatible [e.g. 1.0.0 -> 1.1.0]"
echo "3) major: Breaking changes [e.g. 1.0.0 -> 2.0.0]"

# If version is 0.0.0, suggest starting with 0.1.0 as default
if [ "$current_version" = "0.0.0" ]; then
  echo "For initial release, minor version (option 2) is recommended."
fi

read -p "Enter choice (1-3): " version_type

case $version_type in
  1) bump_type="patch" ;;
  2) bump_type="minor" ;;
  3) bump_type="major" ;;
  *) echo "Invalid choice. Skipping version update."; exit 0 ;;
esac

# Pre-release options
echo ""
echo "Select pre-release status:"
echo "0) none: Not a pre-release version (DEFAULT)"
echo "1) alpha: Early internal testing"
echo "2) beta: Public testing but still unstable"
echo "3) rc: Release candidate, ready to be published publicly"
read -p "Enter choice (0-3) [default: 0]: " prerelease_type

# Default to 0 if no input
prerelease_type=${prerelease_type:-0}

case $prerelease_type in
  0) prerelease="" ;;
  1) prerelease="alpha" ;;
  2) prerelease="beta" ;;
  3) prerelease="rc" ;;
  *) echo "Invalid choice. Using no pre-release tag."; prerelease="" ;;
esac

# Execute npm version to update package.json
if [ -z "$prerelease" ]; then
  npm --no-git-tag-version version $bump_type
else
  # Check if current version already has a prerelease tag
  if [[ $current_version == *"-"* ]]; then
    npm --no-git-tag-version version pre$bump_type --preid=$prerelease
  else
    npm --no-git-tag-version version $bump_type --preid=$prerelease
    npm --no-git-tag-version version pre$prerelease
  fi
fi

# Get new version
new_version=$(node -p "require('./package.json').version")
echo "Updated version to $new_version"

# Add package.json to staging
git add package.json
if [ -f "package-lock.json" ]; then
  git add package-lock.json
fi